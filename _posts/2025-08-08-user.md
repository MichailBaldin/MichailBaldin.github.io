---
layout: post
title: Разработка user-service: от интерфейсов до Docker контейнера
date: 2025-08-04
tags: [go, микросервисы, clean-architecture, postgresql, redis, tdd, docker]
---

# Время писать код!

После настройки CI/CD пришло время создать первый полноценный микросервис. Выбрал user-service как самый базовый — почти все остальные сервисы будут с ним взаимодействовать.

**Цель была простая:** минимально рабочий сервис с чистой архитектурой, без лишних абстракций и преждевременных оптимизаций.

# Архитектурные решения

## Принцип минимализма

С самого начала решил придерживаться правила "меньше — лучше":

- ❌ JWT аутентификация — пока не нужна
- ❌ Сложные валидации — базовая проверка JSON
- ❌ PUT endpoint для обновления — только создание и чтение
- ❌ Фреймворки — чистый net/http
- ✅ Только самое необходимое для работающего сервиса

## API дизайн

Всего 3 эндпоинта:

```
POST /api/v1/users      # Создание пользователя
GET  /api/v1/users/{id} # Получение пользователя
GET  /health            # Health check
```

Этого достаточно для MVP и интеграции с другими сервисами.

## Технологический стек

- **PostgreSQL** — основное хранилище, надежно и знакомо
- **Redis** — кэширование с TTL 5 минут
- **Zap** — структурированное логирование для ELK стека в будущем
- **Testify** — тестирование с моками
- **Docker** — контейнеризация

# Чистая архитектура на практике

Реализовал классическую слоистую архитектуру с инверсией зависимостей:

```
user-service/
├── models/          # Структуры данных и DTO
├── repository/      # Интерфейсы + PostgreSQL + Redis реализации
├── service/         # Бизнес-логика
├── handlers/        # HTTP обработчики
├── config/          # Конфигурация через env
└── main.go          # Склеивание зависимостей
```

## Ключевое решение: интерфейсы везде

Каждый слой зависит только от абстракций:

```go
// repository/interfaces.go
type UserRepository interface {
    Create(user *models.User) error
    GetByID(id int) (*models.User, error)
}

type CacheRepository interface {
    Set(user *models.User) error
    Get(id int) (*models.User, error)
    Delete(id int) error
}

// service/interfaces.go
type UserService interface {
    CreateUser(req *models.CreateUserRequest) (*models.User, error)
    GetUser(id int) (*models.User, error)
}
```

**Преимущества проявились сразу:**

- Тестирование с моками стало простым
- Можно менять реализации без изменения кода
- Компилятор проверяет соответствие интерфейсам

# Пошаговая разработка

Разбил разработку на 9 логических коммитов, каждый — законченная функциональность:

## Commit 1-2: Фундамент

- Зависимости и структура проекта
- Модели данных с JSON тегами и тестами

## Commit 3-4: Интерфейсы и конфигурация

- Определение контрактов между слоями
- Загрузка настроек из environment variables

## Commit 5-6: Слой данных

- PostgreSQL репозиторий с SQL схемой
- Redis кэш с JSON сериализацией
- Тесты для каждой реализации

## Commit 7: Бизнес-логика

- Сервис с кэш-стратегией
- Обработка ошибок кэша как некритичных
- Unit тесты с моками для всех сценариев

## Commit 8: HTTP слой

- Обработчики с правильными status codes
- Извлечение ID из URL пути
- HTTP тесты с httptest

## Commit 9: Склеивание

- main.go с dependency injection
- Запуск рабочего сервиса

# Интересные технические детали

## Кэш-стратегия

Реализовал cache-aside pattern с graceful degradation:

```go
func (s *userService) GetUser(id int) (*models.User, error) {
    // Пробуем кэш
    user, err := s.cacheRepo.Get(id)
    if err != nil {
        s.logger.Warn("Cache error", zap.Error(err))
        // Ошибка кэша — не критично, идем в БД
    }

    if user != nil {
        return user, nil // Cache hit
    }

    // Cache miss — идем в базу
    user, err = s.userRepo.GetByID(id)
    if err != nil {
        return nil, err
    }

    // Обновляем кэш (ошибка некритична)
    s.cacheRepo.Set(user)
    return user, nil
}
```

**Принцип:** кэш повышает производительность, но его недоступность не должна ломать сервис.

## Обработка NOT FOUND

Важное решение — как возвращать "не найдено":

- **Repository слой:** возвращает `(nil, nil)` для отсутствующих записей
- **Service слой:** пропускает `(nil, nil)` дальше
- **Handler слой:** превращает `nil` в HTTP 404

Это четко разделяет ответственность слоев.

## Извлечение ID из URL

Простое решение без роутера:

```go
func (h *UserHandler) extractID(r *http.Request) (int, error) {
    path := r.URL.Path // "/api/v1/users/123"
    parts := strings.Split(path, "/")
    if len(parts) < 4 {
        return 0, fmt.Errorf("invalid path")
    }

    idStr := parts[len(parts)-1] // "123"
    return strconv.Atoi(idStr)
}
```

Работает и не добавляет лишних зависимостей.

# Тестирование — сразу и везде

## Unit тесты с моками

Для service слоя написал тесты всех сценариев:

```go
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) Create(user *models.User) error {
    args := m.Called(user)
    return args.Error(0)
}

// Тестируем cache hit сценарий
func TestUserService_GetUser_CacheHit(t *testing.T) {
    mockCacheRepo.On("Get", 123).Return(expectedUser, nil)

    result, err := service.GetUser(123)

    require.NoError(t, err)
    assert.Equal(t, expectedUser.ID, result.ID)
    mockUserRepo.AssertNotCalled(t, "GetByID") // БД не трогали!
}
```

## HTTP тесты

Для handlers использовал httptest:

```go
func TestUserHandler_CreateUser_Success(t *testing.T) {
    mockService.On("CreateUser", mock.AnythingOfType("*models.CreateUserRequest")).
        Return(expectedUser, nil)

    req := httptest.NewRequest(http.MethodPost, "/api/v1/users", jsonBody)
    w := httptest.NewRecorder()

    handler.CreateUser(w, req)

    assert.Equal(t, http.StatusCreated, w.Code)
    // проверяем JSON response
}
```

## Integration тесты

Для repository слоя заложил основу для integration тестов, но пока пропускаю их через `t.Skip()`. В будущем подключу testcontainers для реальной PostgreSQL в тестах.

# Проблемы и решения

## Проблема с моками и nil

Столкнулся с паникой в тестах:

```
panic: interface conversion: interface {} is nil, not *models.User
```

**Причина:** некорректная обработка nil в моке.

**Решение:**

```go
func (m *MockUserRepository) GetByID(id int) (*models.User, error) {
    args := m.Called(id)
    if args.Get(0) == nil {
        return nil, args.Error(1) // Проверяем nil перед приведением типа
    }
    return args.Get(0).(*models.User), args.Error(1)
}
```

## Golangci-lint ошибки

CI ругался на неиспользуемый код и непроверенные ошибки:

- `const testDSN is unused` — удалил заготовки для integration тестов
- `logger.Sync() not checked` — обернул в defer функцию с проверкой
- `w.Write() not checked` — добавил проверку ошибок

**Урок:** линтер помогает писать более качественный код, не стоит его игнорировать.

# Docker и инфраструктура

## Multi-stage Dockerfile

```dockerfile
FROM golang:1.24-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN go build -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
EXPOSE 8001
CMD ["./main"]
```

Результат — образ ~15MB вместо 300MB+ с полным Go runtime.

## Docker Compose

Простая конфигурация для локальной разработки:

```yaml
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: users
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

  user-service:
    build: ./services/users
    ports:
      - "8001:8001"
    environment:
      POSTGRES_HOST: postgres
      REDIS_ADDR: redis:6379
    depends_on:
      - postgres
      - redis
```

## Makefile для удобства

```makefile
up:
	docker-compose up --build -d

test:
	cd services/users && go test ./...

health:
	curl -s http://localhost:8001/health
```

Одна команда `make up` — и вся система работает.

# Результат

Получился полноценный микросервис:

✅ **Чистая архитектура** с интерфейсами и инверсией зависимостей  
✅ **Высокое покрытие тестами** — unit, HTTP, integration заготовки  
✅ **Graceful degradation** — работает даже при недоступности кэша  
✅ **Structured logging** — готов к централизованному сбору логов  
✅ **Containerized** — запускается одной командой  
✅ **Production ready** — обработка ошибок, health checks, proper HTTP codes

## Тестирование

```bash
# Запуск системы
make up

# Создание пользователя
curl -X POST http://localhost:8001/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"name":"John Doe","email":"john@example.com"}'

# Получение пользователя (проверяем кэширование)
curl http://localhost:8001/api/v1/users/1

# Health check
curl http://localhost:8001/health
```

**Время разработки:** ~6 часов чистого кодинга + 2 часа на тестирование и отладку.

# Выводы

## Что сработало хорошо

**Интерфейсы с самого начала** — тестирование стало простым, код получился слабо связанным.

**Пошаговая разработка** — каждый коммит добавлял законченную функциональность, легко откатываться при проблемах.

**Тесты сразу** — найти баг на этапе написания кода намного проще чем потом.

**Минимализм** — сервис делает одну вещь и делает хорошо.

## Что можно улучшить

**Integration тесты** — пока только заготовки, нужно подключить testcontainers.

**Metrics** — пока только логи, нужен Prometheus для мониторинга.

**Graceful shutdown** — сервис не обрабатывает SIGTERM корректно.

**Connection pooling** — PostgreSQL подключение без пула может стать bottleneck.

Но это все вопросы следующих итераций. Сейчас главное — работающий MVP.

# Следующие шаги

1. **Product-service** — по аналогичной архитектуре
2. **API Gateway** — маршрутизация между сервисами
3. **Мониторинг** — Prometheus + Grafana
4. **Load testing** — проверим на нагрузке

В следующем посте расскажу про создание product-service и то, как переиспользовать архитектурные решения из user-service.

**Код полностью доступен в репозитории в ветке `feature/user-service`.**
